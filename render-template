#!/usr/bin/env python
import argparse
import sys
import os
import pystache
from pystache.common import MissingTags
from renderer_util import extract_sections, merge_yamls, validate_output_path, assert_input_paths, merge_dicts
import logging
import logging.config

LOG_CONFIG_DICT = {"version": 1,
                   "formatters":
                       {"basic": {"format": "'%(asctime)s - %(levelname)s - %(message)s'"}},
                   "handlers":
                       {"console": {"class": "logging.StreamHandler", "level": "INFO", "formatter": "basic"}},
                   "root": {"handlers":["console"]}
                   }

logger = None

def _render_template(templ, data):
    renderer = pystache.Renderer(missing_tags=MissingTags.strict)
    rendered_template = renderer.render(templ, data)
    return rendered_template


def render_template(arg_dict):
    
    templ_path = arg_dict.get('template', None)
    data_file_paths = arg_dict.get('data', None)
    output_path = arg_dict.get('output', None)
    sections = arg_dict.get('yaml_data_section', None)
    loggingcfg = arg_dict.get('loggingcfg', None)
    include_env_vars = arg_dict.get('addenvvars', None)

    if loggingcfg is not None:
        logging.config.fileConfig(loggingcfg)
    else:
        logging.config.dictConfig(LOG_CONFIG_DICT)
    logger = logging.getLogger(__name__)

    assert_input_paths([templ_path])
    validate_output_path(output_path)
    
    data = {}
    if data_file_paths is not None:
    	assert_input_paths(data_file_paths)
        data = merge_yamls(data_file_paths)

    if sections is not None:
	    if data is None or len(data) <= 0:
	        logger.error("Cannot extract sections from empty YAML file data.")
	        return False
	    data = extract_sections(sections, data)
	    if data is None or len(data) <= 0:
	        logger.error("Obtained empty data map after extracting sections from YAML data.")
	        return False
            
    if include_env_vars:
        env_var_map = os.environ
        data = merge_dicts([data, env_var_map])

    if data is None or len(data) <= 0:
        logger.error("Obtained empty data map after merging data from the YAML data file and/or environment variables")
        return False

    try:
        templ_file = open(templ_path)
        templ = templ_file.read()
        rendered_template = _render_template(templ, data)
    except Exception:
        logger.error('Error merging template with data. Please ensure that the template file is well formed, '
                         'has the requisite permissions and the data is in sync with the template\n')
        return False
    try:
        output_file = open(output_path, 'w')
        output_file.write(rendered_template)
        return True
    except Exception:
        logger.error('Error writing output file. Please ensure that the path is valid, the parent directory has '
                         'the required permissions and there is suffice space on the device\n')
        return False

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Merge given mustache template based on given optional data YAML and '
                                                 'environment variables. Note that atleast one of YAML data or environment variables must be provided')
    parser.add_argument('--template', required=True, help='Path to a mustache template file')
    parser.add_argument('--data', required=False, help='Paths to one or more YAML data files from which to fetch values.'
                                                      'Note that each YAML is converted into a hierarchical map.'
                                                      'In case of conflicting keys, the key-values from the YAML appearing '
                                                      'later in the list of files will overwrite existing ones. '
                                                      'The resulting map will be used to substitute values into the template',
                        nargs='+')
    parser.add_argument('--output', required=True,
                        help='The file path to which the de-templatised output must be written')
    parser.add_argument('--yaml_data_section', required=False,
                        help='A list of (hierarchical paths to) sections in the yaml '
                             'file from which to extract Key Value data. '
                             'Note that if multiple such paths are specified, the looked up '
                             'maps are merged before being used for rendering the template.'
                             'The conflict resolution policy in case of colliding keys is the same as '
                             'that used to resolve multiple conflicting YAMLs value files. The Hierarchical '
                             'paths to sections are specified in the form: '
                             'parent_section[.sub_section]+', nargs='+')

    parser.add_argument('--loggingcfg', required=False,
                        help='Location of the logging configuration file using which application wide logging '
                             ' is to be configured. In the absence of this, a console logger at INFO level'
                             ' is configured.')
    parser.add_argument('--addenvvars', required=False,type=bool, default=False,
                        help='Whether or not to include environment variables passed to this process. Can be True or False.'
                             'Defaults to False. Note that environment variables override the map of key-values obtained '
                             'after reading YAML sections.')
    args = vars(parser.parse_args())
    is_successful_render = render_template(args)
    if is_successful_render:
        sys.exit(0)
    else:
        sys.exit(1)
